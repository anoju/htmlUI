<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive JavaScript Array Methods</title>
</head>
<body>
    <h1>Comprehensive JavaScript Array Methods</h1>
    <div id="output"></div>

    <script>
        const output = document.getElementById('output');
        let fruits = ['apple', 'banana', 'orange', 'grape', 'kiwi'];

        function log(message) {
            output.innerHTML += message + '<br>';
        }

        // Existing methods
        log("Original array: " + fruits);

        // 추가/제거
        // push(): 배열의 끝에 요소를 추가하고 반환되는 값은 새로운 길이입니다.
        fruits.push('mango');
        log("After push(): " + fruits);

        // pop(): 배열의 마지막 요소를 제거하고 반환합니다.
        let lastFruit = fruits.pop();
        log("Popped fruit: " + lastFruit);
        log("After pop(): " + fruits);

        // unshift(): 배열의 처음에 요소를 추가하고 반환되는 값은 새로운 길이입니다.
        fruits.unshift('pear');
        log("After unshift(): " + fruits);

        // shift(): 배열의 첫 번째 요소를 제거하고 반환합니다.
        let firstFruit = fruits.shift();
        log("Shifted fruit: " + firstFruit);
        log("After shift(): " + fruits);

        //검색
        // indexOf(): 특정 값이 배열에 있는지 확인하고 찾은 위치를 반환합니다 (값 없으면 -1).
        let bananaIndex = fruits.indexOf('banana');
        log("Index of 'banana': " + bananaIndex);

        // lastIndexOf(): 특정 값이 배열에서 마지막으로 등장한 위치를 반환합니다 (-1은 존재하지 않을 때).
        fruits.push('apple');
        let lastAppleIndex = fruits.lastIndexOf('apple');
        log("Last index of 'apple': " + lastAppleIndex);

        // findIndex(): 배열에서 주어진 조건을 만족하는 요소의 인덱스를 반환합니다. 조건이 맞는 요소가 없으면 -1 을 반환합니다.
        let indexOfLongFruit = fruits.findIndex(fruit => fruit.length > 5);
        log("Index of first fruit with more than 5 characters: " + indexOfLongFruit);
        
        // find(): 배열에서 주어진 조건을 만족하는 첫 번째 요소를 반환합니다. 조건이 맞는 요소가 없으면 undefined 를 반환합니다.
        let foundFruit = fruits.find(fruit => fruit.startsWith('g'));
        log("First fruit starting with 'g': " + foundFruit);

        // includes: 해당 값이 있는지만 반환(true, false)
        log("'바나나'가 있나요? " + fruits.includes('banana'));
        
        // entries(): 배열의 모든 요소를 **키-값(key-value pair)**으로 반환합니다. 키는 인덱스이고, 값은 해당 인덱스에 있는 요소입니다.
        let fruitEntries = fruits.entries();
        log("Entries of fruits array:");
        for (let entry of fruitEntries) {
            log(entry);
        }

        // keys(): 배열의 모든 **인덱스(키)**를 반환합니다.
        let fruitKeys = fruits.keys();
        log("Keys of fruits array:");
        for (let key of fruitKeys) {
            log(key);
        }

        // values(): 배열의 모든 **값(요소)**을 반환합니다.
        let fruitValues = fruits.values();
        log("Values of fruits array:");
        for (let value of fruitValues) {
            log(value);
        }

        // join(): API는 배열의 요소들을 주어진 문자열을 사용하여 연결해서 새로운 문자열을 만드는 메서드입니다.
        let fruitString = fruits.join(' - ');
        log("Joined fruits: " + fruitString);        

        // 순환/변형
        // 중복 제거1
        fruits.push('banana');
        let uniqueFruits = [...new Set(fruits)];
        log("Array after removing duplicates: " + uniqueFruits);

        // 중복 제거2
        let uniqueFruitsAlt = fruits.filter((fruit, index, self) => 
            self.indexOf(fruit) === index
        );
        log("Array after removing duplicates (alternative method): " + uniqueFruitsAlt);

        // slice(): 배열의 특정 부분을 복사하여 새로운 배열을 만듭니다. 시작 인덱스와 끝 인덱스를 지정할 수 있습니다 (끝 인덱스는 포함되지 않습니다).
        let slicedFruits = fruits.slice(1, 3);
        log("Sliced fruits: " + slicedFruits);

        // splice(): 배열의 특정 위치에서 요소를 추가하거나 제거하는 메서드입니다. 시작 인덱스와 삭제할 개수 또는 추가할 요소들을 지정합니다.
        fruits.splice(2, 1, 'cherry', 'blueberry');
        log("After splice(): " + fruits);

        // concat(): 두 개 이상의 배열을 결합하여 하나의 새로운 배열을 반환합니다.
        let moreFruits = ['peach', 'plum'];
        let allFruits = fruits.concat(moreFruits);
        log("Concatenated fruits: " + allFruits);

        // forEach(): 배열의 각 요소를 순회하며 지정된 함수를 실행합니다.
        log("forEach() output:");
        fruits.forEach((fruit, index) => {
            log(`Fruit ${index + 1}: ${fruit}`);
        });

        // map(): 배열의 각 요소를 변형하여 새로운 배열을 반환합니다.
        let upperFruits = fruits.map(fruit => fruit.toUpperCase());
        log("Uppercase fruits: " + upperFruits);

        // filter(): 특정 조건을 만족하는 요소만 포함하여 새로운 배열을 반환합니다.
        let longFruits = fruits.filter(fruit => fruit.length > 5);
        log("Fruits with more than 5 characters: " + longFruits);

        // reduce(): 배열의 요소들을 하나로 합쳐 특정 값을 반환합니다.
        let totalLength = fruits.reduce((sum, fruit) => sum + fruit.length, 0);
        log("Total length of all fruits: " + totalLength);

        // sort(): 배열의 요소를 기본적으로 오름차순으로 정렬합니다.
        fruits.sort();
        log("After sort(): " + fruits);

        // reverse(): 배열의 요소 순서를 역순으로 바꿉니다.
        fruits.reverse();
        log("After reverse(): " + fruits);

        // fill(): 배열의 특정 구간을 새로운 값으로 채웁니다. (기존 요소는 변경됩니다)
        let filledArray = new Array(3).fill('melon');
        log("Filled array: " + filledArray);

        // some(): 배열의 적어도 하나의 요소에 대해 주어진 함수가 참을 반환하는지 확인합니다.
        let hasShortFruit = fruits.some(fruit => fruit.length < 5);
        log("Has fruit with less than 5 characters: " + hasShortFruit);

        // every(): 배열의 모든 요소에 대해 주어진 함수가 참을 반환하는지 확인합니다.
        let allLongFruits = fruits.every(fruit => fruit.length > 3);
        log("All fruits have more than 3 characters: " + allLongFruits);

        // shuffle(): 배열의 요소를 랜덤하게 섞습니다 (Fisher-Yates 셔플 알고리즘 사용)
        function shuffle(array) {
            const shuffled = [...array]; // 원본 배열 복사
            
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            return shuffled;
        }

        let shuffledFruits = shuffle(fruits);
        log("Original fruits: " + fruits);
        log("Shuffled fruits: " + shuffledFruits);

        // 추가 셔플 예시 (원본 배열 직접 수정)
        function shuffleInPlace(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        let testFruits = ['apple', 'banana', 'orange', 'grape', 'kiwi'];
        log("Before in-place shuffle: " + testFruits);
        shuffleInPlace(testFruits);
        log("After in-place shuffle: " + testFruits);
    </script>
</body>
</html>